# 智能体经典范式构建

三种经典范式
- Reasoning and Acting (ReAct)：让智能体边想边做，动态调整
- Plan-and-Solve：让智能体先规划，再严格执行
- Reflection：让智能体“反思”，通过自我批判和修正优化结果

## ReAct

**推理（Reasoning）与行动（Act）**

核心思想：
- **思考**与**行动**是相辅相成的，思考指导行动，行动的结果反过来又修正思考。
- 形成思考->行动->观察的循环
- 调用外部工具，动态调整推理过程

工作流程：
- Thought（思考）：分析问题，制定计划，或者反思上一步的结果
- Action（行动）：采取具体动作，例如调用外部工具
- Observation（观察）：执行Action后从外部工具获取的结果
- 循环迭代，直到最终答案或者循环次数耗尽

特点：
- 高可解释性：能看到完整的推理链
- 动态纠错：可根据观察结果调整策略
- 工具协同：结合 LLM 推理与外部工具执行

局限性：
- 强依赖 LLM 的能力
- 执行效率低（需要多次调用）
- 提示词脆弱，容易出错
- 缺乏全局规划，可能陷入局部最优

适用场景：
- 需要外部知识的任务：例如查询实时信息
- 需要精确计算的任务：例如调用计算器计算
- 需要与API交互的任务：例如操作数据库、调用某个API来完成任务

## Plan-and-Solve

**规划**（Plan）与**求解**（Solve）

核心思想
- 先规划 (Plan) → 后执行 (Solve)
- 由 LLM 先生成完整的行动计划，再逐步执行
  
工作流程
- 规划阶段：分解问题，生成结构化步骤
- 执行阶段：逐步执行计划，传递上下文结果

应用场景：适合结构化、可分解的复杂任务
- 多步数学应用题：需要先列出计算步骤，再逐一求解。
- 需要整合多个信息源的报告撰写：需要先规划好报告结构（引言、数据来源A、数据来源B、总结），再逐一填充内容。
- 代码生成任务：需要先构思好函数、类和模块的结构，再逐一实现。

## Reflection

核心思想
- 引入 **事后反思** (post-hoc reflection) 机制
- **执行 → 反思 → 优化** 的迭代循环
- 模仿人类的“校对/验算”过程

工作流程
- 执行：生成初稿（如代码）
- 反思：由“评审员”角色分析错误与优化方向
- 优化：根据反馈修正，生成新版本
- 可多轮迭代，直到结果收敛

应用场景
- 代码优化：初稿可能低效，反思后改进为更优算法（如筛法）
- 逻辑推理：发现并修复推理漏洞
- 复杂任务：提升最终结果的质量与可靠性

## 习题

1. 三种范式在“思考”与“行动”的组织方式上有什么本质区别
    - ReAct (Reason + Act)，思想和行动紧密**耦合**，形成**循环**，像人类边想边做，本质是**思考驱动行动，行动反过来修正思考**
    - Plan-and-Solve，先集中思考，规划后再执行，像人类先思考再行动，本质是**思考与行动解耦，思考阶段一次性完成，行动阶段只是执行，不再动态调整**
    - Reflection，先执行，再进行事后反思与优化，像人类写完初稿后再校对、修改，本质是**思考与行动分阶段交替，行动先产出结果，思考在事后进行批判与改进**
2. 智能家居控制助手
    - 选ReAct和Reflection
    - 智能家居环境是高度实时的，用户随时可能发出指令（开灯、关窗帘、调节空调）。ReAct 的 思考-行动-观察循环 能够边想边做，快速响应。
    - 每个设备（灯光、空调、窗帘）都可以抽象为一个“工具”。ReAct 能根据用户意图选择合适的工具并立即执行。
    - 如果执行失败（比如设备未响应），ReAct 可以根据观察结果调整策略（重试、换设备、提示用户）。
    - Reflection 可以分析原因并改进，还可以通过事后反思发现规律，并优化策略。
3. 三种范式混合的架构
    - Plan-and-Solve：负责全局规划，生成任务蓝图
    - ReAct：在执行阶段，边想边做，动态调用工具
    - Reflection：在任务完成后，进行事后反思与优化