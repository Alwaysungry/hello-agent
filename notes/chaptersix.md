# 框架开发实践

## 主流框架的选型和对比

| 框架 | 核心概念 | 主要优势 | 典型应用场景 |
| ---- | -------- | ------- | ----------- |
| AutoGen | 对话的智能体 | 自动化多智能体对话流，高度可定制的交互模式 | 自动化代码生成与测试、模拟产品开发流程 |
| AgentScope | 消息传递 | 易用性强，工程化程度高，支持分布式部署 | 构建复杂、可运维的大规模多智能体应用 |
| CAMEL | 角色扮演 | 极简的协作设定，通过初始提示驱动自主对话 | 探索性任务、创意生成、模拟特定领域专家写作 |
| LangGraph | 状态图 | 天然支持循环和条件分支，精准控制复杂工作流 | 实现Reflection、迭代式优化、需要人工介入的流程 |

## AutoGen

### 核心理念与特点
- 多智能体协作：不只是单一的大模型，而是通过多个专门化的Agent（例如Coder、ProductManager、Tester）互相通信来完成复杂任务。
- 自动化工作流：强调任务的分解、调度和执行自动化，减少人工干预（例如，Coder 写完代码后由 Tester 自动接管，智能体在群聊中通过自动化消息传递，不断对话、协作、迭代直至最终目标达成）。
- 人类在环：保留人类随时介入的能力，确保安全性、可控性和灵活性。
- 模块化与可扩展性：设计上鼓励开发者根据需求定制 Agent，组合不同工具链。

### 核心机制

1. 框架结构的演进
  - 分层设计：框架被拆分为两个核心模块
    - autogen-core：框架的底层基础，封装了与语言模型交互、消息传递等核心功能。他的存在保证了框架的稳定性和未来扩展性。
    - autogen-agentchat：构建于core之上，提供了用于开发对话式智能体应用的高级接口，简化了多智能体应用的开发流程。分层策略使得各组件职责明确，降低了系统的耦合度

  - 异步优先：新架构全面转向异步编程（async/await）。
    - 在多智能体协作场景中，网络请求（如调用 LLM API）是主要耗时操作。异步模式允许系统在等待一个智能体响应时处理其他任务，从而避免了线程阻塞，显著提升了并发处理能力和系统资源的利用效率。
  
2. 核心智能体组件
    智能体是执行任务的基本单元。
    - AssistantAgent（助理智能体）：任务的主要解决者，核心是封装了一个大语言模型（LLM）。职责是根据对话历史生成富有逻辑和知识的回复，例如提出计划、撰写文章或者编写代码。通过不同的系统消息（SystemMessage），可以为其赋予不同的“专家”角色。
    - UserProxyAgent（用户代理智能体）：AutoGen中独特的组件。它扮演者双重角色：既是人类用户的“代言人”，负责发起任务和传达意图；又是一个可靠的“执行器”，可以配置为执行代码和调用工具，并将结果反馈给其他智能体。这种设计清晰地区分了“思考”（由AssistantAgent完成）与“行动”。

3. 从 GroupChatManager 到 Team
   - 轮询群聊 (RoundRobinGroupChat)：这是一种明确的、顺序化的对话协调机制。它会让参与的智能体按照预定义的顺序依次发言。这种模式非常适用于流程固定的任务，例如一个典型的软件开发流程：产品经理先提出需求，然后工程师编写代码，最后由代码审查员进行检查。
   - 工作流
     1. 首先，创建一个 RoundRobinGroupChat 实例，并将所有参与协作的智能体（如产品经理、工程师等）加入其中。
     2. 当一个任务开始时，群聊会按照预设的顺序，依次激活相应的智能体。
     3. 被选中的智能体根据当前的对话上下文进行响应。
     4. 群聊将新的回复加入对话历史，并激活下一个智能体。
     5. 这个过程会持续进行，直到达到最大对话轮次或满足预设的终止条件。
    
## AgentScop

### 理念和特点
与AutoGen的核心差异在于其**消息驱动的架构设计**和**工业级的工程实践**，AgentScope就像一个完整的"智能体操作系统"，为开发者提供了从开发、测试到部署的全生命周期支持。

- 多智能体协作：AgentScope通过多个智能体协同完成复杂任务。
- 状态管理：智能体、记忆、工具等均是有状态对象，支持嵌套式状态管理，保证可追溯与可恢复。
- 消息驱动：消息是框架的核心数据结构，用于智能体间通信、用户交互和记忆存储。
- 工具调用：支持任意可调用的Python对象（函数、类方法、异步调用等），更具有灵活扩展能力。
- 实时干预：支持用户在运行过程中介入，保证系统可控。
  
### 核心机制

1. 分层架构体系
   - **基础组件层**：最底层的核心构建块。Message组件定义了统一的消息格式，支持从简单文本到多模态内容；Memory组件提供了短期和长期记忆管理；Model API层抽象了对不同大语言模型的调用；Tool则封装了智能体与外部世界交互的能力。
   - **智能体基础设施层**：包含各种预构建的智能体（如浏览器智能体、深度研究智能体）；实现了ReAct范式，支持智能体钩子、并行工具调用、状态管理等高级特性。原生支持**异步执行与实时控制**。
   - **多智能体协作层**：创新所在。MsgHub作为消息中心，负责智能体间的消息路由和状态管理；Pipeline提供灵活的工作流编排能力，支持顺序、并发等多种执行模式。
   - **开发与部署层**：最上层，AgentScope Runtime提供了生产级的运行时环境，AgentScope Studio为开发者提供了完整的可视化开发工具链。
2. 消息驱动
  创新核心所在，所有智能体交互都被抽象为消息的发送和接收，而不是传统的函数调用。
  - **异步解耦**：消息的发送方和接收方在时间上解耦，无需相互等待，天然支持高并发场景。
  - **位置透明**：智能体无需关心另一个智能体的位置，消息系统会自动处理路由
  - **可观测行**：每一条消息都可以被记录、追踪和分析，极大的简化了复杂系统的调试与监控。
  - **可靠性**：消息可以被持久化存储和重试，即使系统出现故障，也能保证交互的最终一致性，提升了系统的容错能力。
3. 智能体生命周期管理
   在 AgentScope 中，每个智能体都有明确的生命周期（初始化、运行、暂停、销毁等），并基于一个统一的基类 AgentBase 来实现。开发者通常只需要关注其核心的 reply 方法。
   ```Python
   from agentscope.agents import AgentBase

   class CustomAgent(AgentBase):
       def __init__(self, name: str, **kwargs):
           super().__init__(name=name, **kwargs)
           # 智能体初始化逻辑
       
       def reply(self, x: Msg) -> Msg:
           # 智能体的核心响应逻辑
           response = self.model(x.content)
           return Msg(name=self.name, content=response, role="assistant")
       
       def observe(self, x: Msg) -> None:
           # 智能体的观察逻辑（可选）
           self.memory.add(x)
   ```
4. 消息传递机制
   AgentScope 内置了一个消息中心 (MsgHub)，它是整个消息驱动架构的中枢。MsgHub 不仅负责消息的路由和分发，还集成了持久化和分布式通信等高级功能，它有以下这些特点。
   - **灵活的消息路由**：支持点对点、广播、组播等多种通信模式，可以构建灵活复杂的交互网络。
   - **消息持久化**：能够将所有消息自动保存到数据库（如SQLite，MongoDB），确保了长期运行任务的状态可以被恢复。
   - **原生分布式支持**：这是 AgentScope 的标志性特性。智能体可以被部署在不同的进程或服务器上，MsgHub 会通过 RPC（远程过程调用）自动处理跨节点的通信，对开发者完全透明。

   