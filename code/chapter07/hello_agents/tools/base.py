from typing import Any, Dict, List, Optional, Callable, get_type_hints
from pydantic import BaseModel
from abc import ABC, abstractmethod
import inspect
import re

def tool_action(name: str = None, description: str = "") -> Callable:
    """
    工具动作装饰器：用于标记工具类中的方法为可调用的工具动作。
    """
    def decorator(func: Callable) -> Callable:
        func._is_tool_action = True
        func._tool_name = name if name else func.__name__
        func._tool_description = description
        return func
    return decorator

class ToolParameter(BaseModel):
    """
    工具参数类：定义了工具参数的名称、类型和描述。
    """
    name: str
    description: str
    type: str  # e.g., "string", "integer", etc.
    required: bool = True # 是否为必需参数
    default: Any = None # 可选的默认值


class Tool(ABC):
    """
    工具基类：定义了工具的核心接口和基本行为，所有具体的工具实现都应继承自该类。
    支持两种使用模式：
    1. 普通模式：工具作为单一实体使用
    2. 可展开模式：工具可以展开为多个独立的子工具（每个子工具对应一个功能）

    展开模式支持两种实现方式：
    - 手动定义子工具类（传统方式）
    - 使用@tool_action装饰器自动生成子工具（推荐方式）
    通过反射机制，自动识别并注册被@tool_action装饰的方法
    """
    def __init__(self, name: str, description: str, expandable: bool = False):
        self.name = name
        self.description = description
        self.expandable = expandable

    @abstractmethod
    def run(self, parameters: Dict[str, Any]) -> Any:
        """
        运行工具，处理输入参数并返回结果。
        具体实现应由子类完成。
        """
        pass

    @abstractmethod
    def get_parameters(self) -> List[ToolParameter]:
        """
        获取工具的参数定义。
        具体实现应由子类完成。
        """
        pass

    def get_expanded_tools(self) -> Optional[List["Tool"]]:
        """
        获取展开的子工具列表（如果有）。
        具体实现应由子类完成。
        """
        if not self.expandable:
            return None
        
        tools = []
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            if hasattr(method, '_is_tool_action'):
                tool = AutoGeneratedTool(
                    parent_tool=self,
                    method=method,
                    name=method._tool_name,
                    description=method._tool_description
                )
                tools.append(tool)
        return tools

class AutoGeneratedTool(Tool):
    """
    自动生成的工具类：从方法签名和docstring自动提取参数。
    """
    def __init__(self, parent_tool: Tool, method: Callable, name: str, description: str = None):
        """初始化自动生成的工具

        Args:
            parent_tool (Tool): 父工具实例
            method (Callable): 被装饰的方法
            name (str): 工具名称
            description (str, optional): 工具描述. Defaults to None.
        """
        self.parent_tool = parent_tool
        self.method = method

        if name is None:
            # 从方法名生成工具名
            method_name = method.__name__.lstrip('_')
            name = f"{parent_tool.name}_{method_name}"
        
        # 提取描述
        if description is None:
            description = self._extract_description_from_docstring()
        
        super().__init__(name=name, description=description)

        self._parameters = self._parse_parameters() # 解析参数列表

    def _extract_description_from_docstring(self) -> str:
        """从 docstring 提取描述

        Returns:
            str: 描述字符串
        """
        doc = inspect.getdoc(self.method)
        if not doc:
            return f"执行 {self.method.__name__}"

        lines = doc.splitlines()
        for line in lines:
            line = line.strip()
            if line and not line.startswith("Args:") and not line.startswith("Returns:"):
                return line
        return f"执行 {self.method.__name__}"
    
    def _parse_parameters(self) -> List[ToolParameter]:
        """从方法签名和 docstring 自动提取参数

        Returns:
            List[ToolParameter]: 参数列表
        """
        sig = inspect.signature(self.method)
        type_hints = get_type_hints(self.method)
        doc = inspect.getdoc(self.method) or ""

        # 从docstring 解析参数描述
        param_descriptions = self._parse_param_descriptions(doc)

        parameters = []
        for param_name, param in sig.parameters.items():
            if param_name == 'self':
                continue
            
            # 提取类型
            param_type_hint = type_hints.get(param_name, str)
            param_type = self._map_python_type_to_tool_type(param_type_hint)

            # 判断是否必需
            required = param.default == inspect.Parameter.empty
            default = None if required else param.default

            # 提取描述
            description = param_descriptions.get(param_name, f"参数 {param_name}")

            parameters.append(ToolParameter(
                name=param_name,
                description=description,
                type=param_type,
                required=required,
                default=default
            ))
        return parameters
    
    def _parse_param_descriptions(self, docstring: str) -> Dict[str, str]:
        """解析 docstring 中的参数描述

        Args:
            docstring (str): 方法的 docstring

        Returns:
            Dict[str, str]: 参数名称到描述的映射
        """
        param_descs = {}
        param_section = re.search(r'Args:\s*(.*?)\s*(Returns:|$)', docstring, re.DOTALL)
        if param_section:
            param_lines = param_section.group(1).strip().splitlines()
            for line in param_lines:
                match = re.match(r'(\w+)\s*:\s*(.*)', line.strip())
                if match:
                    param_name, description = match.groups()
                    param_descs[param_name] = description.strip()
        return param_descs
    
    def _python_type_to_tool_type(self, py_type: type) -> str:
        """将 Python 类型映射到工具参数类型

        Args:
            py_type (type): Python 类型

        Returns:
            str: 工具参数类型字符串
        """
        if py_type in [str]:
            return "string"
        elif py_type in [int]:
            return "integer"
        elif py_type in [float]:
            return "number"
        elif py_type in [bool]:
            return "boolean"
        elif py_type in [list, List]:
            return "array"
        elif py_type in [dict, Dict]:
            return "object"
        else:
            return "string"  # 默认类型
        
    def get_parameters(self) -> List[ToolParameter]:
        return self._parameters
    
    def run(self, parameters: Dict[str, Any]) -> Any:
        return self.method(**parameters)