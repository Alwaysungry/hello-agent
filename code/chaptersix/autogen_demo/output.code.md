\n\n```python\nimport streamlit as st\nimport requests\nimport time\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.graph_objects as go\nimport json\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any, Tuple, List\nimport functools\nfrom dataclasses import dataclass\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport random\nfrom functools import wraps\n\n# ==================== æ—¥å¿—é…ç½® ====================\nclass AppLogger:\n    """åº”ç”¨æ—¥å¿—è®°å½•å™¨"""\n    \n    def __init__(self, name: str = "bitcoin_tracker"):\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(logging.INFO)\n        \n        if not self.logger.handlers:\n            console_handler = logging.StreamHandler()\n            console_handler.setLevel(logging.INFO)\n            \n            file_handler = RotatingFileHandler(\n                \'app.log\',\n                maxBytes=1024*1024,\n                backupCount=5\n            )\n            file_handler.setLevel(logging.DEBUG)\n            \n            formatter = logging.Formatter(\n                \'%(asctime)s - %(name)s - %(levelname)s - %(message)s\'\n            )\n            console_handler.setFormatter(formatter)\n            file_handler.setFormatter(formatter)\n            \n            self.logger.addHandler(console_handler)\n            self.logger.addHandler(file_handler)\n    \n    def log_api_call(self, url: str, status: str, duration: float):\n        self.logger.info(f"APIè°ƒç”¨: {url} - çŠ¶æ€: {status} - è€—æ—¶: {duration:.2f}s")\n    \n    def log_error(self, error_type: str, message: str, exc_info=None):\n        self.logger.error(f"{error_type}: {message}", exc_info=exc_info)\n    \n    def log_user_action(self, action: str, details: dict = None):\n        details_str = f" - è¯¦æƒ…: {details}" if details else ""\n        self.logger.info(f"ç”¨æˆ·æ“ä½œ: {action}{details_str}")\n\n# ==================== é…ç½®ç®¡ç† ====================\nclass ConfigManager:\n    """é…ç½®ç®¡ç†å™¨"""\n    \n    def __init__(self, config_file: str = "config.json"):\n        self.config_file = Path(config_file)\n        self.default_config = {\n            "api": {\n                "base_url": "https://api.coingecko.com/api/v3",\n                "timeout": 10,\n                "rate_limit": 30,\n                "max_retries": 3,\n                "cache_ttl": 30\n            },\n            "app": {\n                "refresh_interval": 30,\n                "theme": "dark",\n                "chart_days": 1,\n                "max_cache_items": 100\n            },\n            "ui": {\n                "chart_height": 400,\n                "show_market_info": True,\n                "show_statistics": True,\n                "enable_auto_refresh": False\n            }\n        }\n        self.config = self.load_config()\n    \n    def load_config(self):\n        if self.config_file.exists():\n            try:\n                with open(self.config_file, \'r\', encoding=\'utf-8\') as f:\n                    user_config = json.load(f)\n                    return self._deep_merge(self.default_config, user_config)\n            except (json.JSONDecodeError, IOError) as e:\n                print(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}, ä½¿ç”¨é»˜è®¤é…ç½®")\n                return self.default_config\n        return self.default_config\n    \n    def _deep_merge(self, base: dict, update: dict) -> dict:\n        result = base.copy()\n        for key, value in update.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                result[key] = self._deep_merge(result[key], value)\n            else:\n                result[key] = value\n        return result\n    \n    def save_config(self):\n        try:\n            with open(self.config_file, \'w\', encoding=\'utf-8\') as f:\n                json.dump(self.config, f, indent=2, ensure_ascii=False)\n            return True\n        except IOError as e:\n            print(f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")\n            return False\n    \n    def get(self, key: str, default=None):\n        keys = key.split(\'.\')\n        value = self.config\n        for k in keys:\n            if isinstance(value, dict) and k in value:\n                value = value[k]\n            else:\n                return default\n        return value\n    \n    def set(self, key: str, value):\n        keys = key.split(\'.\')\n        config = self.config\n        \n        for k in keys[:-1]:\n            if k not in config:\n                config[k] = {}\n            config = config[k]\n        \n        config[keys[-1]] = value\n        self.save_config()\n\n# ==================== ä¸»é¢˜ç®¡ç† ====================\nclass ThemeManager:\n    """ä¸»é¢˜ç®¡ç†å™¨"""\n    \n    THEMES = {\n        \'dark\': {\n            \'background\': \'rgba(0,0,0,0)\',\n            \'text_color\': \'white\',\n            \'grid_color\': \'rgba(128, 128, 128, 0.2)\',\n            \'up_color\': \'#00FF00\',\n            \'down_color\': \'#FF4444\',\n            \'card_bg\': \'rgba(30, 30, 30, 0.7)\',\n            \'primary_color\': \'#F7931A\'\n        },\n        \'light\': {\n            \'background\': \'white\',\n            \'text_color\': \'black\',\n            \'grid_color\': \'rgba(128, 128, 128, 0.1)\',\n            \'up_color\': \'#00AA00\',\n            \'down_color\': \'#AA0000\',\n            \'card_bg\': \'rgba(240, 240, 240, 0.9)\',\n            \'primary_color\': \'#E67E22\'\n        }\n    }\n    \n    @classmethod\n    def get_colors(cls, theme: str = \'dark\'):\n        return cls.THEMES.get(theme, cls.THEMES[\'dark\'])\n\n# ==================== æ€§èƒ½ç›‘æ§è£…é¥°å™¨ ====================\ndef monitor_performance(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        try:\n            result = func(*args, **kwargs)\n            duration = time.time() - start_time\n            \n            if \'performance_stats\' not in st.session_state:\n                st.session_state.performance_stats = {}\n            \n            func_name = func.__name__\n            if func_name not in st.session_state.performance_stats:\n                st.session_state.performance_stats[func_name] = {\n                    \'count\': 0,\n                    \'total_time\': 0,\n                    \'avg_time\': 0,\n                    \'min_time\': float(\'inf\'),\n                    \'max_time\': 0\n                }\n            \n            stats = st.session_state.performance_stats[func_name]\n            stats[\'count\'] += 1\n            stats[\'total_time\'] += duration\n            stats[\'avg_time\'] = stats[\'total_time\'] / stats[\'count\']\n            stats[\'min_time\'] = min(stats[\'min_time\'], duration)\n            stats[\'max_time\'] = max(stats[\'max_time\'], duration)\n            \n            if duration > 5.0:\n                st.warning(f"å‡½æ•° {func_name} æ‰§è¡Œæ—¶é—´è¿‡é•¿: {duration:.2f}ç§’")\n            \n            return result\n        except Exception as e:\n            duration = time.time() - start_time\n            st.error(f"å‡½æ•° {func.__name__} æ‰§è¡Œå¤±è´¥ï¼Œè€—æ—¶ {duration:.2f}ç§’: {str(e)}")\n            raise\n    \n    return wrapper\n\n# ==================== ç¼“å­˜ç®¡ç† ====================\nCACHE_NAMESPACE = "__cache__"\n\ndef cleanup_cache():\n    current_time = time.time()\n    keys_to_delete = []\n    \n    for key in list(st.session_state.keys()):\n        if key.startswith(CACHE_NAMESPACE):\n            if isinstance(st.session_state[key], tuple) and len(st.session_state[key]) == 2:\n                _, timestamp = st.session_state[key]\n                if current_time - timestamp > 300:\n                    keys_to_delete.append(key)\n    \n    for key in keys_to_delete:\n        del st.session_state[key]\n\ndef cache_with_expiry(seconds: int = 30):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            cache_key = f"{CACHE_NAMESPACE}_{func.__name__}_{hash(str(args) + str(kwargs))}"\n            \n            if cache_key in st.session_state:\n                cached_data, timestamp = st.session_state[cache_key]\n                if time.time() - timestamp < seconds:\n                    return cached_data\n            \n            result = func(*args, **kwargs)\n            \n            if result is not None:\n                st.session_state[cache_key] = (result, time.time())\n            \n            if random.random() < 0.1:\n                cleanup_cache()\n            \n            return result\n        return wrapper\n    return decorator\n\n# ==================== æ•°æ®æ¨¡å‹ ====================\n@dataclass\nclass BitcoinPriceData:\n    """æ¯”ç‰¹å¸ä»·æ ¼æ•°æ®æ¨¡å‹"""\n    current_price: float\n    price_change_24h: float\n    price_change_amount_24h: float\n    market_cap: float\n    volume_24h: float\n    last_updated: int\n    price_history: List[List[float]]\n    timestamp: float\n    \n    @property\n    def is_positive(self) -> bool:\n        return self.price_change_24h > 0 if self.price_change_24h is not None else False\n\n# ==================== æ ¼å¼åŒ–å·¥å…· ====================\nclass DataFormatter:\n    """æ•°æ®æ ¼å¼åŒ–å·¥å…·ç±»"""\n    \n    @staticmethod\n    def format_currency(value: Optional[float], currency: str = \'USD\') -> str:\n        if value is None:\n            return "N/A"\n        return f"{currency} {value:,.2f}"\n    \n    @staticmethod\n    def format_percentage(value: Optional[float], decimals: int = 2) -> str:\n        if value is None:\n            return "N/A"\n        sign = \'+\' if value > 0 else \'\'\n        return f"{sign}{value:.{decimals}f}%"\n    \n    @staticmethod\n    def format_timestamp(timestamp: Optional[int], \n                         format_str: str = "%Y-%m-%d %H:%M:%S") -> str:\n        if not timestamp:\n            return "N/A"\n        try:\n            dt = datetime.fromtimestamp(timestamp)\n            return dt.strftime(format_str)\n        except (ValueError, TypeError):\n            return "N/A"\n    \n    @staticmethod\n    def format_large_number(value: Optional[float]) -> str:\n        if value is None:\n            return "N/A"\n        \n        if value >= 1_000_000_000:\n            return f"${value/1_000_000_000:.2f}B"\n        elif value >= 1_000_000:\n            return f"${value/1_000_000:.2f}M"\n        else:\n            return f"${value:,.0f}"\n\n# ==================== æ¯”ç‰¹å¸ä»·æ ¼æœåŠ¡ ====================\nclass BitcoinPriceService:\n    """æ¯”ç‰¹å¸ä»·æ ¼æœåŠ¡ç±»"""\n    \n    def __init__(self, config: ConfigManager, logger: AppLogger):\n        self.config = config\n        self.logger = logger\n        self.session = requests.Session()\n        self.session.headers.update({\n            \'User-Agent\': \'BitcoinPriceTracker/2.0\',\n            \'Accept\': \'application/json\'\n        })\n    \n    @monitor_performance\n    def validate_price_data(self, data: Dict[str, Any]) -> Tuple[bool, str]:\n        if not data:\n            return False, "æ•°æ®ä¸ºç©º"\n        \n        required_fields = {\n            \'current_price\': (float, "å½“å‰ä»·æ ¼"),\n            \'price_change_24h\': (float, "24å°æ—¶æ¶¨è·Œå¹…"),\n            \'last_updated\': (int, "æœ€åæ›´æ–°æ—¶é—´")\n        }\n        \n        for field, (field_type, field_name) in required_fields.items():\n            if field not in data:\n                return False, f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field_name}"\n            \n            if data[field] is None:\n                return False, f"{field_name}ä¸ºç©º"\n            \n            if not isinstance(data[field], field_type):\n                return False, f"{field_name}ç±»å‹é”™è¯¯"\n        \n        if data[\'current_price\'] <= 0:\n            return False, "ä»·æ ¼å¿…é¡»å¤§äº0"\n        \n        if data[\'current_price\'] > 1000000:\n            return False, "ä»·æ ¼å¼‚å¸¸åé«˜"\n        \n        try:\n            update_time = datetime.fromtimestamp(data[\'last_updated\'])\n            current_time = datetime.now()\n            \n            if update_time > current_time + timedelta(hours=1):\n                return False, "æ›´æ–°æ—¶é—´åœ¨æœªæ¥"\n            if update_time < current_time - timedelta(days=7):\n                return False, "æ•°æ®è¿‡äºé™ˆæ—§"\n        except (ValueError, TypeError):\n            return False, "æ—¶é—´æˆ³æ ¼å¼é”™è¯¯"\n        \n        return True, "éªŒè¯é€šè¿‡"\n    \n    @monitor_performance\n    @cache_with_expiry(seconds=30)\n    def fetch_bitcoin_data(self) -> Optional[BitcoinPriceData]:\n        max_retries = self.config.get(\'api.max_retries\', 3)\n        timeout = self.config.get(\'api.timeout\', 10)\n        base_url = self.config.get(\'api.base_url\')\n        \n        for attempt in range(max_retries):\n            start_time = time.time()\n            try:\n                price_url = f"{base_url}/simple/price"\n                price_params = {\n                    \'ids\': \'bitcoin\',\n                    \'vs_currencies\': \'usd\',\n                    \'include_24hr_change\': \'true\',\n                    \'include_24hr_vol\': \'true\',\n                    \'include_market_cap\': \'true\',\n                    \'include_last_updated_at\': \'true\'\n                }\n                \n                price_response = self.session.get(\n                    price_url, \n                    params=price_params, \n                    timeout=timeout\n                )\n                price_response.raise_for_status()\n                price_data = price_response.json()\n                \n                chart_url = f"{base_url}/coins/bitcoin/market_chart"\n                chart_params = {\n                    \'vs_currency\': \'usd\',\n                    \'days\': str(self.config.get(\'app.chart_days\', 1)),\n                    \'interval\': \'hourly\'\n                }\n                \n                chart_response = self.session.get(\n                    chart_url,\n                    params=chart_params,\n                    timeout=timeout\n                )\n                chart_response.raise_for_status()\n                chart_data = chart_response.json()\n                \n                bitcoin_data = price_data.get(\'bitcoin\', {})\n                \n                current_price = bitcoin_data.get(\'usd\')\n                price_change_pct = bitcoin_data.get(\'usd_24h_change\')\n                price_change_amount = 0\n                if current_price and price_change_pct:\n                    price_change_amount = current_price * (price_change_pct / 100)\n                \n                result_data = {\n                    \'current_price\': current_price,\n                    \'price_change_24h\': price_change_pct,\n                    \'price_change_amount_24h\': price_change_amount,\n                    \'market_cap\': bitcoin_data.get(\'usd_market_cap\'),\n                    \'volume_24h\': bitcoin_data.get(\'usd_24h_vol\'),\n                    \'last_updated\': bitcoin_data.get(\'last_updated_at\'),\n                    \'price_history\': chart_data.get(\'prices\', []),\n                    \'timestamp\': time.time()\n                }\n                \n                is_valid, message = self.validate_price_data(result_data)\n                \n                if is_valid:\n                    duration = time.time() - start_time\n                    self.logger.log_api_call(price_url, "æˆåŠŸ", duration)\n                    return BitcoinPriceData(**result_data)\n                else:\n                    self.logger.log_error("æ•°æ®éªŒè¯å¤±è´¥", message)\n                    \n                    if attempt < max_retries - 1:\n                        wait_time = 1 * (attempt + 1)\n                        time.sleep(wait_time)\n                        continue\n                    else:\n                        return None\n                    \n            except requests.exceptions.Timeout:\n                duration = time.time() - start_time\n                self.logger.log_error("è¯·æ±‚è¶…æ—¶", f"ç¬¬{attempt + 1}æ¬¡å°è¯•è¶…æ—¶ï¼Œè€—æ—¶: {duration:.2f}s")\n                \n                if attempt < max_retries - 1:\n                    wait_time = 2 * (attempt + 1)\n                    time.sleep(wait_time)\n                    continue\n                else:\n                    st.error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥")\n                    return None\n                    \n            except requests.exceptions.RequestException as e:\n                duration = time.time() - start_time\n                self.logger.log_error("ç½‘ç»œè¯·æ±‚é”™è¯¯", str(e))\n                \n                if attempt == max_retries - 1:\n                    st.error(f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {str(e)}")\n                    return None\n                    \n                wait_time = 1 * (attempt + 1)\n                time.sleep(wait_time)\n                \n            except ValueError as e:\n                self.logger.log_error("æ•°æ®è§£æé”™è¯¯", str(e))\n                st.error(f"æ•°æ®è§£æé”™è¯¯: {str(e)}")\n                return None\n                \n            except Exception as e:\n                self.logger.log_error("æœªçŸ¥é”™è¯¯", str(e), exc_info=True)\n                st.error(f"æœªçŸ¥é”™è¯¯: {str(e)}")\n                return None\n        \n        return None\n\n# ==================== å›¾è¡¨ç”Ÿæˆå™¨ ====================\nclass ChartGenerator:\n    """å›¾è¡¨ç”Ÿæˆå™¨ç±»"""\n    \n    def __init__(self, config: ConfigManager, theme_manager: ThemeManager):\n        self.config = config\n        self.theme_manager = theme_manager\n    \n    @monitor_performance\n    def create_price_chart(self, price_history: List[List[float]], \n                          title: str = "ä»·æ ¼èµ°åŠ¿") -> Optional[go.Figure]:\n        if not price_history or len(price_history) < 2:\n            return None\n        \n        try:\n            theme = self.config.get(\'app.theme\', \'dark\')\n            colors = self.theme_manager.get_colors(theme)\n            \n            timestamps = [item[0] for item in price_history]\n            prices = [item[1] for item in price_history]\n            \n            dates = [datetime.fromtimestamp(ts/1000) for ts in timestamps]\n            \n            first_price = prices[0]\n            last_price = prices[-1]\n            trend_color = colors[\'up_color\'] if last_price >= first_price else colors[\'down_color\']\n            \n            fig = go.Figure()\n            \n            fig.add_trace(go.Scatter(\n                x=dates,\n                y=prices,\n                mode=\'lines\',\n                name=\'æ¯”ç‰¹å¸ä»·æ ¼\',\n                line=dict(color=trend_color, width=2),\n                fill=\'tozeroy\',\n                fillcolor=f\'rgba({int(trend_color[1:3], 16)}, {int(trend_color[3:5], 16)}, {int(trend_color[5:7],', type='TextMessage'), TextMessage(id='bf416c20-2933-42dd-b20b-ec7699ee5ca6', source='Engineer', models_usage=RequestUsage(prompt_tokens=39571, completion_tokens=4096), metadata={}, created_at=datetime.datetime(2026, 1, 8, 15, 3, 40, 874799, tzinfo=datetime.timezone.utc), content='16)}, 0.1)\',\n                hovertemplate=\'<b>%{x|%H:%M}</b><br>$%{y:.2f}<extra></extra>\'\n            ))\n            \n            fig.add_trace(go.Scatter(\n                x=[dates[-1]],\n                y=[prices[-1]],\n                mode=\'markers+text\',\n                name=\'å½“å‰ä»·æ ¼\',\n                marker=dict(size=10, color=\'white\', line=dict(width=2, color=trend_color)),\n                text=[f\'${prices[-1]:.2f}\'],\n                textposition=\'top center\',\n                showlegend=False\n            ))\n            \n            fig.update_layout(\n                title=dict(\n                    text=title,\n                    font=dict(size=16, color=colors[\'text_color\'])\n                ),\n                xaxis=dict(\n                    title="æ—¶é—´",\n                    gridcolor=colors[\'grid_color\'],\n                    tickformat="%H:%M",\n                    showgrid=True\n                ),\n                yaxis=dict(\n                    title="ä»·æ ¼ (USD)",\n                    tickprefix="$",\n                    gridcolor=colors[\'grid_color\'],\n                    showgrid=True\n                ),\n                template="plotly_dark" if theme == \'dark\' else "plotly_white",\n                hovermode="x unified",\n                height=self.config.get(\'ui.chart_height\', 400),\n                margin=dict(l=20, r=20, t=50, b=20),\n                plot_bgcolor=colors[\'background\'],\n                paper_bgcolor=colors[\'background\']\n            )\n            \n            return fig\n            \n        except Exception as e:\n            st.error(f"ç”Ÿæˆå›¾è¡¨æ—¶å‡ºé”™: {str(e)}")\n            return None\n\n# ==================== Streamlitåº”ç”¨ ====================\nclass BitcoinPriceApp:\n    """æ¯”ç‰¹å¸ä»·æ ¼åº”ç”¨ä¸»ç±»"""\n    \n    def __init__(self):\n        self.config = ConfigManager()\n        self.logger = AppLogger()\n        self.theme_manager = ThemeManager()\n        self.formatter = DataFormatter()\n        \n        self.service = BitcoinPriceService(self.config, self.logger)\n        self.chart_generator = ChartGenerator(self.config, self.theme_manager)\n        \n        self._init_session_state()\n    \n    def _init_session_state(self):\n        defaults = {\n            \'price_data\': None,\n            \'last_update\': None,\n            \'auto_refresh\': self.config.get(\'ui.enable_auto_refresh\', False),\n            \'last_manual_refresh\': 0,\n            \'theme\': self.config.get(\'app.theme\', \'dark\'),\n            \'refresh_count\': 0,\n            \'error_count\': 0,\n            \'user_preferences\': {}\n        }\n        \n        for key, value in defaults.items():\n            if key not in st.session_state:\n                st.session_state[key] = value\n    \n    def setup_page(self):\n        st.set_page_config(\n            page_title="Bitcoin Price Tracker Pro",\n            page_icon="â‚¿",\n            layout="wide",\n            initial_sidebar_state="expanded"\n        )\n        \n        self._apply_custom_css()\n    \n    def _apply_custom_css(self):\n        theme = st.session_state.theme\n        colors = self.theme_manager.get_colors(theme)\n        \n        css = f"""\n        <style>\n        .main-header {{\n            font-size: 2.5rem;\n            font-weight: bold;\n            color: {colors[\'primary_color\']};\n            text-align: center;\n            margin-bottom: 1rem;\n        }}\n        .price-card {{\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            border-radius: 10px;\n            padding: 20px;\n            color: white;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n        }}\n        .metric-card {{\n            background: {colors[\'card_bg\']};\n            border-radius: 10px;\n            padding: 15px;\n            border-left: 4px solid {colors[\'primary_color\']};\n        }}\n        .positive {{\n            color: {colors[\'up_color\']};\n        }}\n        .negative {{\n            color: {colors[\'down_color\']};\n        }}\n        .stButton > button {{\n            width: 100%;\n        }}\n        </style>\n        """\n        st.markdown(css, unsafe_allow_html=True)\n    \n    def render_sidebar(self):\n        with st.sidebar:\n            st.title("âš™ï¸ è®¾ç½®")\n            \n            theme_options = ["dark", "light"]\n            current_theme = st.session_state.theme\n            theme_index = theme_options.index(current_theme) if current_theme in theme_options else 0\n            \n            new_theme = st.selectbox(\n                "é€‰æ‹©ä¸»é¢˜",\n                theme_options,\n                index=theme_index\n            )\n            \n            if new_theme != st.session_state.theme:\n                st.session_state.theme = new_theme\n                self.config.set(\'app.theme\', new_theme)\n                self.logger.log_user_action("åˆ‡æ¢ä¸»é¢˜", {"theme": new_theme})\n                st.rerun()\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                auto_refresh = st.checkbox(\n                    "è‡ªåŠ¨åˆ·æ–°",\n                    value=st.session_state.auto_refresh,\n                    help="å¯ç”¨è‡ªåŠ¨åˆ·æ–°åŠŸèƒ½"\n                )\n            \n            with col2:\n                if auto_refresh:\n                    refresh_intervals = [30, 60, 120]\n                    current_interval = self.config.get(\'app.refresh_interval\', 30)\n                    interval_index = refresh_intervals.index(current_interval) if current_interval in refresh_intervals else 0\n                    \n                    refresh_interval = st.selectbox(\n                        "åˆ·æ–°é—´éš”(ç§’)",\n                        refresh_intervals,\n                        index=interval_index,\n                        help="è‡ªåŠ¨åˆ·æ–°çš„æ—¶é—´é—´éš”"\n                    )\n                    \n                    if refresh_interval != current_interval:\n                        self.config.set(\'app.refresh_interval\', refresh_interval)\n                else:\n                    refresh_interval = self.config.get(\'app.refresh_interval\', 30)\n            \n            if auto_refresh != st.session_state.auto_refresh:\n                st.session_state.auto_refresh = auto_refresh\n                self.config.set(\'ui.enable_auto_refresh\', auto_refresh)\n                self.logger.log_user_action("åˆ‡æ¢è‡ªåŠ¨åˆ·æ–°", {"enabled": auto_refresh})\n                st.rerun()\n            \n            st.markdown("---")\n            \n            st.subheader("ğŸ“Š å›¾è¡¨è®¾ç½®")\n            chart_days = st.selectbox(\n                "å›¾è¡¨æ˜¾ç¤ºå¤©æ•°",\n                [1, 7, 30],\n                index=0,\n                help="ä»·æ ¼å›¾è¡¨æ˜¾ç¤ºçš„å¤©æ•°èŒƒå›´"\n            )\n            \n            if chart_days != self.config.get(\'app.chart_days\', 1):\n                self.config.set(\'app.chart_days\', chart_days)\n                st.session_state.price_data = None\n                st.rerun()\n            \n            st.markdown("---")\n            \n            if self.config.get(\'ui.show_statistics\', True):\n                st.subheader("ğŸ“ˆ ç»Ÿè®¡")\n                col1, col2 = st.columns(2)\n                with col1:\n                    st.metric("åˆ·æ–°æ¬¡æ•°", st.session_state.refresh_count)\n                with col2:\n                    st.metric("é”™è¯¯æ¬¡æ•°", st.session_state.error_count)\n            \n            st.markdown("---")\n            \n            st.subheader("â„¹ï¸ å…³äº")\n            st.markdown("""\n            **æ•°æ®æ¥æº**: CoinGecko API  \n            **æ›´æ–°é¢‘ç‡**: 30ç§’/æ¬¡  \n            **ç‰ˆæœ¬**: 2.0.0  \n            \n            [APIæ–‡æ¡£](https://www.coingecko.com/api/documentation)\n            """)\n            \n            if st.checkbox("æ˜¾ç¤ºæ€§èƒ½ç»Ÿè®¡", False):\n                st.markdown("---")\n                st.subheader("âš¡ æ€§èƒ½ç»Ÿè®¡")\n                if \'performance_stats\' in st.session_state:\n                    for func_name, stats in st.session_state.performance_stats.items():\n                        st.text(f"{func_name}:")\n                        st.text(f"  è°ƒç”¨æ¬¡æ•°: {stats[\'count\']}")\n                        st.text(f"  å¹³å‡è€—æ—¶: {stats[\'avg_time\']:.3f}s")\n                        st.text(f"  æœ€å°è€—æ—¶: {stats[\'min_time\']:.3f}s")\n                        st.text(f"  æœ€å¤§è€—æ—¶: {stats[\'max_time\']:.3f}s")\n    \n    def render_header(self):\n        col1, col2, col3 = st.columns([2, 1, 1])\n        \n        with col1:\n            st.markdown(\'<div class="main-header">â‚¿ Bitcoin Price Tracker Pro</div>\', \n                       unsafe_allow_html=True)\n            st.markdown("å®æ—¶æ¯”ç‰¹å¸ä»·æ ¼ç›‘æ§ä¸æ•°æ®åˆ†æ")\n        \n        with col2:\n            current_time = time.time()\n            cooldown_remaining = max(0, 30 - (current_time - st.session_state.last_manual_refresh))\n            \n            if cooldown_remaining > 0:\n                st.button(\n                    f"ğŸ”„ å†·å´ä¸­ ({int(cooldown_remaining)}s)",\n                    disabled=True,\n                    use_container_width=True,\n                    help="è¯·ç­‰å¾…å†·å´æ—¶é—´ç»“æŸ"\n                )\n            else:\n                if st.button("ğŸ”„ åˆ·æ–°æ•°æ®", use_container_width=True, help="æ‰‹åŠ¨åˆ·æ–°ä»·æ ¼æ•°æ®"):\n                    st.session_state.last_manual_refresh = current_time\n                    st.session_state.price_data = None\n                    st.session_state.refresh_count += 1\n                    self.logger.log_user_action("æ‰‹åŠ¨åˆ·æ–°")\n                    st.rerun()\n        \n        with col3:\n            if st.session_state.last_update:\n                last_update_str = self.formatter.format_timestamp(\n                    st.session_state.last_update,\n                    "%H:%M:%S"\n                )\n                st.caption(f"æœ€åæ›´æ–°: {last_update_str}")\n            else:\n                st.caption("ç­‰å¾…æ•°æ®...")\n    \n    def render_price_display(self, price_data: BitcoinPriceData):\n        with st.container():\n            col1, col2, col3 = st.columns([2, 1, 1])\n            \n            with col1:\n                st.markdown(\'<div class="price-card">\', unsafe_allow_html=True)\n                st.markdown(f"### {self.formatter.format_currency(price_data.current_price)}")\n                \n                change_class = "positive" if price_data.is_positive else "negative"\n                change_icon = "ğŸ“ˆ" if price_data.is_positive else "ğŸ“‰"\n                \n                col_change1, col_change2 = st.columns(2)\n                with col_change1:\n                    st.markdown(f\'<div class="{change_class}">\'\n                               f\'{change_icon} {self.formatter.format_percentage(price_data.price_change_24h)}\'\n                               \'</div>\', unsafe_allow_html=True)\n                \n                with col_change2:\n                    change_amount = self.formatter.format_currency(\n                        abs(price_data.price_change_amount_24h)\n                    )\n                    direction = "ä¸Šæ¶¨" if price_data.is_positive else "ä¸‹è·Œ"\n                    st.markdown(f\'<div class="{change_class}">\'\n                               f\'{direction} {change_amount}\'\n                               \'</div>\', unsafe_allow_html=True)\n                \n                st.markdown(\'</div>\', unsafe_allow_html=True)\n            \n            with col2:\n                with st.container():\n                    st.markdown(\'<div class="metric-card">\', unsafe_allow_html=True)\n                    st.metric(\n                        "å¸‚å€¼",\n                        self.formatter.format_large_number(price_data.market_cap)\n                    )\n                    st.markdown(\'</div>\', unsafe_allow_html=True)\n            \n            with col3:\n                with st.container():\n                    st.markdown(\'<div class="metric-card">\', unsafe_allow_html=True)\n                    st.metric(\n                        "24häº¤æ˜“é‡",\n                        self.formatter.format_large_number(price_data.volume_24h)\n                    )\n                    st.markdown(\'</div>\', unsafe_allow_html=True)\n    \n    def render_chart(self, price_data: BitcoinPriceData):\n        if price_data.price_history:\n            chart_title = f"{self.config.get(\'app.chart_days\', 1)}å¤©ä»·æ ¼èµ°åŠ¿"\n            fig = self.chart_generator.create_price_chart(price_data.price_history, chart_title)\n            if fig:\n                st.plotly_chart(fig, use_container_width=True, theme=st.session_state.theme)\n    \n    def render_market_info(self):\n        if self.config.get(\'ui.show_market_info\', True):\n            st.markdown("---")\n            st.subheader("ğŸ“ˆ å¸‚åœºæ¦‚è§ˆ")\n            \n            cols = st.columns(4)\n            market_info = [\n                ("å¸‚å€¼æ’å", "#1", "å…¨çƒåŠ å¯†è´§å¸"),\n                ("æµé€šä¾›åº”", "19.5M BTC", "çº¦93%å·²æµé€š"),\n                ("æ€»ä¾›åº”é‡", "21M BTC", "æœ€å¤§ä¾›åº”ä¸Šé™"),\n                ("å‘è¡Œæ—¶é—´", "2009-01-03", "ä¸­æœ¬èªåˆ›ä¸–åŒºå—")\n            ]\n            \n            for idx, (title, value, desc) in enumerate(market_info):\n                with cols[idx]:\n                    st.metric(title, value, desc)\n    \n    def handle_auto_refresh(self):\n        if st.session_state.auto_refresh:\n            current_time = time.time()\n            last_update = st.session_state.last_update\n            refresh_interval = self.config.get(\'app.refresh_interval\', 30)\n            \n            if last_update and (current_time - last_update) > refresh_interval:\n                with st.spinner(f"è‡ªåŠ¨åˆ·æ–°ä¸­..."):\n                    price_data = self.service.fetch_bitcoin_data()\n                    if price_data:\n                        st.session_state.price_data = price_data\n                        st.session_state.last_update = current_time\n                        st.session_state.refresh_count += 1\n                        self.logger.log_user_action("è‡ªåŠ¨åˆ·æ–°")\n                        st.rerun()\n            \n            if last_update:\n                next_refresh = last_update + refresh_interval\n                time_left = max(0, next_refresh - current_time)\n                \n                progress = 1 - (time_left / refresh_interval)\n                st.progress(progress, text=f"â±ï¸ ä¸‹æ¬¡åˆ·æ–°: {int(time_left)}ç§’å")\n    \n    def render_footer(self):\n        st.markdown("---")\n        \n        with st.expander("âš ï¸ å…è´£å£°æ˜", expanded=False):\n            st.markdown("""\n            ### é‡è¦å£°æ˜\n            \n            1. **ä¿¡æ¯ä»…ä¾›å‚è€ƒ**: æœ¬åº”ç”¨æä¾›çš„æ‰€æœ‰æ•°æ®ä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚\n            2. **æ•°æ®å‡†ç¡®æ€§**: æ•°æ®æ¥è‡ªç¬¬ä¸‰æ–¹APIï¼Œå¯èƒ½å­˜åœ¨å»¶è¿Ÿæˆ–ä¸å‡†ç¡®çš„æƒ…å†µã€‚\n            3. **æŠ•èµ„é£é™©**: åŠ å¯†è´§å¸ä»·æ ¼æ³¢åŠ¨å‰§çƒˆï¼ŒæŠ•èµ„éœ€è°¨æ…ï¼Œé£é™©è‡ªè´Ÿã€‚\n            4. **æŠ€æœ¯é£é™©**: ç½‘ç»œæ•…éšœã€APIé™åˆ¶ç­‰å› ç´ å¯èƒ½å½±å“æ•°æ®è·å–ã€‚\n            \n            **ä½¿ç”¨æœ¬åº”ç”¨å³è¡¨ç¤ºæ‚¨åŒæ„ä»¥ä¸Šæ¡æ¬¾ã€‚**\n            """)\n        \n        current_year = datetime.now().year\n        st.caption(f"Â© {current_year} Bitcoin Price Tracker Pro â€¢ ç‰ˆæœ¬ 2.0.0 â€¢ æœ€åæ›´æ–°: {datetime.now().strftime(\'%Y-%m-%d\')}")\n    \n    def run(self):\n        try:\n            self.setup_page()\n            \n            self.render_sidebar()\n            \n            self.render_header()\n            \n            if st.session_state.price_data is None:\n                with st.spinner("æ­£åœ¨è·å–æ¯”ç‰¹å¸ä»·æ ¼æ•°æ®..."):\n                    price_data = self.service.fetch_bitcoin_data()\n                    \n                    if price_data:\n                        st.session_state.price_data = price_data\n                        st.session_state.last_update = time.time()\n                        st.rerun()\n                    else:\n                        st.error("æ— æ³•è·å–æ¯”ç‰¹å¸ä»·æ ¼æ•°æ®ï¼Œè¯·ç¨åé‡è¯•ã€‚")\n                        st.session_state.error_count += 1\n                        \n                        col1, col2 = st.columns(2)\n                        with col1:\n                            if st.button("ğŸ”„ é‡è¯•", use_container_width=True):\n                                st.session_state.price_data = None\n                                st.rerun()\n                        with col2:\n                            if st.button("ğŸ“‹ æŸ¥çœ‹æ—¥å¿—", use_container_width=True):\n                                st.info("è¯·æŸ¥çœ‹åº”ç”¨ç›®å½•ä¸‹çš„ app.log æ–‡ä»¶è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯")\n                        return\n            \n            self.render_price_display(st.session_state.price_data)\n            \n            self.render_chart(st.session_state.price_data)\n            \n            self.render_market_info()\n            \n            self.handle_auto_refresh()\n            \n            self.render_footer()\n            \n        except Exception as e:\n            self.logger.log_error("åº”ç”¨è¿è¡Œé”™è¯¯", str(e), exc_info=True)\n            st.error(f"åº”ç”¨è¿è¡Œå‡ºé”™: {str(e)}")\n            st.info("è¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼Œæˆ–æ£€æŸ¥æ—¥å¿—æ–‡ä»¶è·å–è¯¦ç»†ä¿¡æ¯ã€‚")\n\n# ==================== ä¸»ç¨‹åºå…¥å£ ====================\ndef main():\n    try:\n        app = BitcoinPriceApp()\n        app.run()\n    except Exception as e:\n        logger = AppLogger()\n        logger.log_error("åº”ç”¨å¯åŠ¨å¤±è´¥", str(e), exc_info=True)\n        \n        st.error(f"åº”ç”¨å¯åŠ¨å¤±è´¥: {str(e)}")\n        st.info("""\n        å¯èƒ½çš„åŸå› ï¼š\n        1. ç½‘ç»œè¿æ¥é—®é¢˜\n        2. é…ç½®æ–‡ä»¶æŸå\n        3. ä¾èµ–åŒ…ç¼ºå¤±\n        \n        è¯·å°è¯•ï¼š\n        1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n        2. åˆ é™¤ config.json æ–‡ä»¶åé‡è¯•\n        3. é‡æ–°å®‰è£…ä¾èµ–åŒ…\n        """)\n\nif __name__ == "__main__":\n    main()\n```